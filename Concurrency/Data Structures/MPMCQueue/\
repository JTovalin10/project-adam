#ifndef MPMCQUEUE_H_
#define MPMCQUEUE_H_

#include <atomic>
#include <cstddef>
#include <memory>
#include <new>
#include <vector>

#include "../utils/HazardPointer/HazardPointer.h"

static const auto CACHE_SIZE = std::hardware_constructive_interference_size;

template <typename T>
class MPMCQueue {
  using size_type = std::size_t;

 public:
  explicit MPMCQueue(size_t capacity)
      : capacity_(capacity), buffer_(capacity_), hp_(10) {
    for (size_t i{}; i < capacity_; i++) {
      buffer_[i].store(nullptr, std::memory_order_relaxed);
    }
  }

  MPMCQueue(const MPMCQueue& other) = delete;

  MPMCQueue& operator=(const MPMCQueue& other) = delete;

  ~MPMCQueue() = default;

  MPMCQueue(MPMCQueue&& other) = delete;

  MPMCQueue operator=(MPMCQueue&& other) = delete;

  // spins until space avaliable
  void push(T element) {
    T* item = new T(std::move(element));
    while (true) {
      size_t current = producer_.index.load(std::memory_order_relaxed);
      size_t next = (current + 1) % capacity_;
      if (next == consumer_.index.load(std::memory_order_acquire)) {
        continue;
      }

      if (producer_.index.compare_exchange_weak(current, next,
                                                std::memory_order_release,
                                                std::memory_order_relaxed)) {
        buffer_[current].store(item);
        break;
      }
    }
  }

  // one attempt to push
  bool try_push(T element) {
    T* item = new T(std::move(element));

    size_t current = producer_.index.load(std::memory_order_relaxed);
    size_t next = (current + 1) % capacity_;

    if (next == consumer_.index.load(std::memory_order_acquire)) {
      delete item;
      return false;
    }

    if (producer_.index.compare_exchange_weak(current, next,
                                              std::memory_order_release,
                                              std::memory_order_relaxed)) {
      buffer_[current].store(item, std::memory_order_release);
      return true;
    }

    delete item;
    return false;
  }

  std::shared_ptr<T> pop() {
    while (true) {
      size_t current = consumer_.index.load(std::memory_order_relaxed);
      size_t next = (current + 1) % capacity_;

      // if empty
      if (current == producer_.index.load(std::memory_order_acquire)) {
        return std::shared_ptr<T>();
      }

      T* item = buffer_[current].load(std::memory_order_acquire);
      while (item == nullptr) {
        item = buffer_[current].load(std::memory_order_acquire);
      }
      hp_.protect(item);

      if (consumer_.index.compare_exchange_weak(current, next,
                                                std::memory_order_release,
                                                std::memory_order_relaxed)) {
        // set to nullptr for the spin lock
        buffer_[current].store(nullptr, std::memory_order_release);
        hp_.release();
        auto deleter = [this](T* ptr) { hp_.retire(ptr); };
        return std::shared_ptr<T>(item, deleter);
      }

      hp_.release();
    }
  }

  std::shared_ptr<T> try_pop() {
    size_t current = consumer_.index.load(std::memory_order_relaxed);
    size_t next = (current + 1) % capacity_;
    if (next == producer_.index.load(std::memory_order_acquire)) {
      return false;
    }

    T* item = buffer_[current].load(std::memory_order_acquire);
    while (item == nullptr) {
      item = buffer_[current].load(std::memory_order_acquire);
    }
    hp_.protect(item);

    if (consumer_.index.compare_exchange_weak(current, next,
                                              std::memory_order_release,
                                              std::memory_order_relaxed)) {
      buffer_[current].store(nullptr, std::memory_order_release);
      auto deleter = [this](T* ptr) { return hp_.retire(ptr); };
      hp_.release();
      return std::shared_ptr<T>(item, deleter);
    }
    hp_.release();
  }

  bool empty() const {
    return consumer_.index.load(std::memory_order_relaxed) ==
           producer_.index.load(std::memory_order_relaxed);
  }

 private:
  size_t capacity_;
  std::vector<std::atomic<T*>> buffer_;
  HazardPointer<T> hp_;
  alignas(CACHE_SIZE) struct {
    std::atomic<size_t> index;
  } consumer_;

  alignas(CACHE_SIZE) struct {
    std::atomic<size_t> index;
  } producer_;
};

#endif  // MPMCQUEUE_H_
